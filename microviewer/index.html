<!doctype html>
<html>

<head>
  <title>μViewer</title>
  <script src="https://accounts.google.com/gsi/client" onload="initTokenClient()" async defer></script>
  <script src="./jquery-3.7.0.min.js"></script>
  <script src="./pako.min.js"></script>
  <script src="./UPNG.js"></script>
  <script src="./crackle.js"></script>
  <script src="./datacube.js"></script>
  <script>
    const config = {
      clientId: '349854005841-dpnhpllibup26ook2tibarhnd7d3r406.apps.googleusercontent.com',
      scope: 'https://www.googleapis.com/auth/devstorage.read_write'
    };
    window.appConfig = config;
  </script>
  <meta charset="utf-8">

  <link rel="preload" as="image" href="./cursors/exact.png">
  <link rel="preload" as="image" href="./cursors/small.png">
  <link rel="preload" as="image" href="./cursors/medium.png">
  <link rel="preload" as="image" href="./cursors/large.png">
  <link rel="preload" as="image" href="./cursors/exact-active.png">
  <link rel="preload" as="image" href="./cursors/small-active.png">
  <link rel="preload" as="image" href="./cursors/medium-active.png">

  <style>
    html {
      overflow: hidden;
    }

    body {
      font-family: monospace;
      color: white;
      background: #0d0d0d;
    }

    #infobar {
      margin-bottom: 10px;
    }

    #brush-tools {
      display: flex;
      justify-content: left;
    }

    #invert-selection {
      margin-left: 5px;
    }

    #brush-size {
      height: 35px;

      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-around;
      width: 150px;

      border: 1px solid #4a4a4a;
      padding: 10px;
    }

    #brush-size div {
      border-radius: 50%;
      background-color: white;
      width: 20px;
      height: 20px;
      transition: background-color .4s ease;
      cursor: pointer;
    }

    #brush-size div:hover {
      background-color: #add9c8;
    }

    #brush-size div:first-child {
      width: 10px;
      height: 10px;
    }

    #brush-size div:nth-child(2) {
      width: 17px;
      height: 17px;
    }

    #brush-size div:nth-child(3) {
      width: 24px;
      height: 24px;
    }

    #brush-size div:last-child {
      width: 30px;
      height: 30px;
    }

    #brush-size.exact div:first-child,
    #brush-size.small div:nth-child(2),
    #brush-size.medium div:nth-child(3),
    #brush-size.large div:nth-child(4) {
      background-color: #80d0b2;
    }

    #right-sidebar {
      position: fixed;
      top: 0px;
      right: 0px;
      z-index: 20;

      background-color: #1a1a1a;
      height: 100vh;
      width: 500px;
      padding-left: 20px;

      transition: right .4s ease;

      border-left: 1px solid #4a4a4a;
      box-sizing: border-box;
      overflow-y: auto;
    }

    #right-sidebar.hidden {
      right: -500px;
    }

    #show-sidebar {
      position: fixed;
      top: 10px;
      right: 510px;

      background-color: #eee;
      z-index: 30;

      width: 60px;
      height: 60px;

      display: flex;
      justify-content: center;
      box-sizing: border-box;
      flex-direction: column;
      border-radius: 50%;

      cursor: pointer;
      transition: right .4s ease;
    }

    #show-sidebar.hidden {
      right: 15px;
    }

    #show-sidebar:hover {
      background-color: white;
    }

    #show-sidebar:active {
      background-color: #ccc;
    }

    #show-sidebar hr {
      width: 25px;
      height: 1px;
      background-color: black;
      border-color: black;
    }

    #show-sidebar hr:first-child {
      position: relative;
      top: 6px;
    }

    #show-sidebar hr:last-child {
      position: relative;
      bottom: 6px;
    }

    #basic-info {
      margin-top: 10px;
    }

    #instructions {
      position: relative;
      z-index: 0;

      width: 450px;
    }

    img {
      margin: 1px;
    }

    #addsegs {
      width: 420px;
      height: 10ex;

      margin-top: 15px;
    }

    #selected_segments {
      max-height: 200px;
      overflow-y: scroll;
      background-color: #4a4a4a;
      padding: 1em;
      width: 400px;
    }

    canvas {
      position: relative;
      border: 1px dotted white;
      max-width: calc(100vw - 20px);
      max-height: calc(100vh - 100px);
      background: #0d0d0d;
      z-index: 10;

      image-rendering: crisp-edges;
      image-rendering: pixelated;
      /* chrome  */
      transition: transform .4s ease, bottom .4s ease, left .4s ease;
      cursor: crosshair;
    }

    canvas.paintable.exact {
      cursor: url("./cursors/exact.png") 20 20.5, crosshair;
    }

    canvas.paintable.exact:active {
      cursor: url("./cursors/exact-active.png") 20 20.5, crosshair;
      /* F7EDCE, color of active state */
    }

    canvas.paintable.small {
      cursor: url("./cursors/small.png") 16 16, crosshair
    }

    canvas.paintable.small:active {
      cursor: url("./cursors/small-active.png") 16 16, crosshair
    }

    canvas.paintable.medium {
      cursor: url("./cursors/medium.png") 28.5 28.5, crosshair
    }

    canvas.paintable.medium:active {
      cursor: url("./cursors/medium-active.png") 28.5 28.5, crosshair
    }

    canvas.paintable.large {
      cursor: url("./cursors/large.png") 53.5 53.5, crosshair
    }

    canvas.paintable.large:active {
      cursor: url("./cursors/large-active.png") 53.5 53.5, crosshair
    }
  </style>

  <script>
    class CircularUndo {
      constructor(n) {
        this.buffer = [];
        this.n = n;
        for (let i = 0; i < this.n; i++) {
          this.buffer.push(null);
        }
        this.index = 0;
        this.offset = 0;
        this.length = 0;
        this.bottom = true;
      }

      incr() {
        if (this.bottom) {
          this.bottom = false;
          if (this.length > 0) {
            return;
          }
        }

        if (this.length > 0) {
          this.index++;
        }
        if (this.index === this.n) {
          this.index = 0;
        }

        if (this.position() < this.length) {
          return;
        }

        this.length++;
        if (this.length > this.n) {
          this.length = this.n;
          this.offset++;
          if (this.offset === this.n) {
            this.offset = 0;
          }
        }
      }

      decr() {
        if (this.length === 0) {
          return;
        }
        else if (this.index === this.offset) {
          this.bottom = true;
          return;
        }

        this.index--;
        if (this.index === -1) {
          this.index = this.n - 1;
        }
      }

      position() {
        if (this.index === -1) {
          return -1;
        }
        else if (this.offset <= this.index) {
          return this.index - this.offset;
        }
        return this.index + (this.n - this.offset);
      }

      get() {
        return this.buffer[this.index];
      }

      isDupe(item) {
        let last = this.get();

        if (last === null) {
          return false;
        }
        else if (item[0] !== last[0]) {
          return false;
        }
        else if (item[0] === 'select') {
          return JSON.stringify(item[1][0]) === JSON.stringify(last[1][0]);
        }
        else {
          let [arr1, axis1, slice1] = last[1];
          let [arr2, axis2, slice2] = item[1];
          if (axis1 !== axis2 || slice1 !== slice2) {
            return false;
          }

          return arr1.every((v, i) => v === arr2[i]);
        }
      }

      push(action) {
        let item = null;
        if (
          (action === undefined && elems.paintmode.prop("checked"))
          || (action === 'paint')
        ) {
          let img2d = vol.getSegmentation().slice(AXIS, SLICE[AXIS], true);
          item = ['paint', [img2d, AXIS, SLICE[AXIS]]];
        }
        else {
          item = ['select', [structuredClone(vol.segments)]];
        }

        if (this.isDupe(item)) {
          return;
        }

        this.incr();
        this.buffer[this.index] = item;

        if (this.position() < this.length - 1) {
          this.length = this.position() + 1;
        }
      }

      undo() {
        if (this.bottom) {
          return;
        }
        this.decr();
        this.do();
      }

      redo() {
        if (this.position() === this.length - 1) {
          return;
        }
        this.incr();
        this.do();
      }

      do() {
        let cur = this.get();
        if (cur === null) {
          return;
        }
        let [action, args] = cur;
        if (action === 'paint') {
          let [img2d, axis, slice] = args;
          vol.getSegmentation().insertSquare(
            img2d, axis, slice
          );
          setUploadProgress(0);
        }
        else {
          vol.segments = structuredClone(args[0]);
        }
        render(true);
      }
    }

    var AXIS = 'z';
    var SLICE = { x: 0, y: 0, z: 0 };
    var CLICK = { x: 0, y: 0, z: 0, pxvalue: [] };
    var SIZE = {};
    var PARAMETERS = {};
    var PXVALUE = [];
    var MOUSE_OVER_IMAGE = false;
    var MAGNIFICATION = 1;
    var BRUSH = 0;
    var PAINTING_MODE = 0;
    var PAINT_MOVED = false;
    var UNDO = new CircularUndo(250);

    let BRUSH_DIAMETERS = {
      0: 1, // px
      1: 25,
      2: 50,
      3: 100,
    };

    var elems;
    var _needsrender = true;

    function create_datacube(dtype, num_bytes, size) {
      let floating = dtype === 'float32' || dtype == 'float64';

      if (floating) {
        return new FloatingPointDataCube({
          bytes: num_bytes,
          size: size,
        });
      }
      else if (dtype == 'bool') {
        return new BooleanDataCube({
          size: size,
        });
      }

      return new DataCube({
        bytes: num_bytes,
        size: size,
      });
    }

    function configure_segmentation_ui() {
      $(channel).on('mousemove', function (e) {
        e.stopPropagation();
        MOUSE_OVER_IMAGE = true;

        let x = e.offsetX / $(channel).innerWidth(),
          y = e.offsetY / $(channel).innerHeight();

        x = clamp(x, 0, 0.999999999);
        y = clamp(y, 0, 0.999999999);

        if (AXIS == 'z') {
          SLICE.x = (x * SIZE.x) | 0;
          SLICE.y = (y * SIZE.y) | 0;
        }
        else if (AXIS == 'y') {
          SLICE.x = (x * SIZE.x) | 0;
          SLICE.z = (y * SIZE.z) | 0;
        }
        else if (AXIS == 'x') {
          SLICE.y = (x * SIZE.y) | 0;
          SLICE.z = (y * SIZE.z) | 0;
        }

        render();
      });

      function paint(evt) {
        var x = evt.offsetX / $(channel).innerWidth(),
          y = evt.offsetY / $(channel).innerHeight();

        x = clamp(x, 0, 0.999999999);
        y = clamp(y, 0, 0.999999999);

        let diameter = BRUSH_DIAMETERS[BRUSH];
        let dx = diameter / $(channel).innerWidth();
        let dy = diameter / $(channel).innerHeight();

        if (ZOOMED) {
          dx /= ZOOM_FACTOR;
          dy /= ZOOM_FACTOR;
        }

        if (evt.which === 1) {
          if (elems.paintmode.prop("checked")) {
            let label = parseInt(elems.paintlabel.val());
            if (!isNaN(label)) {
              vol.paintCircle(AXIS, SLICE[AXIS], dx, dy, x, y, label);
              setUploadProgress(0);
            }
          }
          else {
            vol.selectSegsInCircle(AXIS, SLICE[AXIS], dx, dy, x, y);
          }
        }

        render(true);
      }

      function erase(evt) {
        var x = evt.offsetX / $(channel).innerWidth(),
          y = evt.offsetY / $(channel).innerHeight();

        x = clamp(x, 0, 0.999999999);
        y = clamp(y, 0, 0.999999999);

        let diameter = BRUSH_DIAMETERS[BRUSH];
        let dx = diameter / $(channel).innerWidth();
        let dy = diameter / $(channel).innerHeight();

        if (ZOOMED) {
          dx /= ZOOM_FACTOR;
          dy /= ZOOM_FACTOR;
        }

        if (elems.paintmode.prop("checked")) {
          vol.paintCircle(AXIS, SLICE[AXIS], dx, dy, x, y, 0);
          setUploadProgress(0);
        }
        else {
          vol.eraseSegsInCircle(AXIS, SLICE[AXIS], dx, dy, x, y);
        }
        render(true);
      }

      if (vol.has_segmentation) {
        $(document).on("mousemove", function () {
          MOUSE_OVER_IMAGE = false;
          PAINTING_MODE = 0;
          render();
        });

        $(channel)
          .on('click', function (evt) {
            if (BRUSH > 0 || PAINT_MOVED) {
              return;
            }

            let innerWidth = $(channel).innerWidth();
            let innerHeight = $(channel).innerHeight();

            var x = evt.offsetX / innerWidth,
              y = evt.offsetY / innerHeight;

            x = clamp(x, 0, 0.999999999);
            y = clamp(y, 0, 0.999999999);

            if (evt.which === 1) {
              UNDO.push();
              vol.toggleSegment(AXIS, SLICE[AXIS], x, y);
              UNDO.push();
            }
          })
          .on('mousedown', function (evt) {
            PAINTING_MODE = 1;
            UNDO.push();
            if (BRUSH === 0) {
              PAINT_MOVED = false;
              return;
            }
            paint(evt);
            evt.stopPropagation();
          })
          .on('mouseup', function (evt) {
            PAINTING_MODE = 0;
            UNDO.push();
            render(true);
            evt.stopPropagation();
          })
          .on('mousemove', function (evt) {
            if (PAINTING_MODE > 0) {
              PAINT_MOVED = true;
              if (PAINTING_MODE === 1) {
                paint(evt);
              }
              else {
                erase(evt);
              }
            }
            evt.stopPropagation();
          })
          .on('contextmenu', function (evt) {
            PAINTING_MODE = 2;
            PAINT_MOVED = false;
            UNDO.push();
            erase(evt);
            evt.stopPropagation();
            evt.preventDefault();
          });
      }
    }

    function setup_single_volume(data) {
      render_static();

      let datacube = create_datacube(data.data_types[0], data.data_bytes, SIZE);

      if (data.layer_type === 'segmentation') {
        window.vol = new SegmentationVolume(datacube, true);
      }
      else {
        window.vol = new MonoVolume(datacube, false);
      }

      let vol = window.vol;

      vol.load('/channel', function (ratio) {
        render();
        UNDO.push();
      }).then(() => render());

      configure_segmentation_ui();
    }

    function setup_hyper_volume(data) {
      render_static();

      function get_cube(index) {
        return create_datacube(data.data_types[index], data.data_bytes[index], SIZE);
      }

      window.vol = new HyperVolume(get_cube(0), get_cube(1));
      let vol = window.vol;

      vol.load(function (ratio) {
        render();
        UNDO.push();
      }).then(() => render());

      configure_segmentation_ui();
    }

    function toggleMenu() {
      elems.rtsidebar.toggleClass("hidden");
      elems.showsidebar.toggleClass("hidden");
    }

    function setUploadProgress(progress) {
      document.getElementById('gcsUploadProgress').setAttribute('value', progress);
    }
    function getUploadProgress() {
      return document.getElementById('gcsUploadProgress').getAttribute('value');
    }

    function uploadJSON(json, gcsPath) {
      const uploadJSON = new Promise((resolve, reject) => {
        const path = parseGCSPath(gcsPath);
        const gcsUrl = `https://www.googleapis.com/upload/storage/v1/b/${path.bucketName}/o?uploadType=media&name=${path.objectName}`;
        fetch(gcsUrl, {
          method: 'POST',
          cache: 'no-cache',
          headers: new Headers({
            'Authorization': 'Bearer ' + ACCESS_TOKEN,
            'Content-Type': 'application/json',
          }),
          body: JSON.stringify(json),
        }).then(response => {
          if (response.ok) {
            resolve(response);
          } else {
            reject(response);
          }
        }).catch(error => {
          reject(error);
        })
      });
    }

    function uploadPNG(arrayBuffer, gcsPath) {
      return new Promise((resolve, reject) => {
        const path = parseGCSPath(gcsPath);
        const gcsUrl = `https://www.googleapis.com/upload/storage/v1/b/${path.bucketName}/o?uploadType=media&name=${path.objectName}`;
        fetch(gcsUrl, {
          method: 'POST',
          cache: 'no-cache',
          headers: new Headers({
            'Authorization': 'Bearer ' + ACCESS_TOKEN,
            'Content-Type': 'image/png',
          }),
          body: new Blob([arrayBuffer], { type: 'image/png' }),
        }).then(response => {
          if (response.ok) {
            resolve(response);
          } else {
            reject(response);
          }
        }).catch(error => {
          reject(error);
        })
      });
    }

    function uploadSegmentationToGCS() {
      let d = new Date();
      let backupName = `backup-${d.getFullYear()}-${d.getMonth()}-${d.getDay()}`;
      let currentName = 'latest';

      const urlParams = new URLSearchParams(window.location.search);
      const segPath = normalizeURL(urlParams.get('seg_path'));

      const boundsStr = `${PARAMETERS.bounds[0]}-${PARAMETERS.bounds[3]}_${PARAMETERS.bounds[1]}-${PARAMETERS.bounds[4]}_${PARAMETERS.bounds[2]}-${PARAMETERS.bounds[5]}`;

      const segVol = vol.getSegmentation()
      const cubeview = new Uint8Array(segVol.cube.buffer, 0, segVol.cube.byteLength);
      const arrayBuffer = UPNG.encodeLL([cubeview], segVol.size.x, segVol.size.y * segVol.size.z, 1, 0, 8);
      setUploadProgress(0);

      getToken().then((tokenResponse) => {
        ACCESS_TOKEN = tokenResponse.access_token;
        // Overwrite 'latest' segmentation
        uploadPNG(arrayBuffer, `${segPath}/${currentName}/${boundsStr}`)
          .then(() => setUploadProgress(getUploadProgress() + 45))
          .catch(err => console.log(err));

        // Upload copy of 'latest' segmentation as timestamped backup
        uploadPNG(arrayBuffer, `${segPath}/${backupName}/${boundsStr}`)
          .then(() => setUploadProgress(getUploadProgress() + 45))
          .catch(err => console.log(err));

        // Ensure info points to 'latest'
        fetch(toHTTPS(segPath) + `/info?cacheBuster=${Date.now()}`, { cache: "no-cache" })
          .then(response => response.json())
          .then(data => {
            data.scales[0].key = currentName;
            uploadJSON(data, segPath + '/info')
              .then(() => setUploadProgress(getUploadProgress() + 10))
              .catch(err => console.log(err));
          });
      }).catch(err => console.log(err));
    }

    ACCESS_TOKEN = null;

    function initTokenClient() {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: appConfig.clientId,
        scope: appConfig.scope,
        callback: ""
      });

      document.getElementById('gcsUpload').disabled = false;
      document.getElementById('gcsUploadProgress').style.display = 'block';
    }

    function getToken(force=false) {
      // old Token should still be valid
      if (force === false && Date.now() < localStorage.getItem('tokenExpires')) {
        const tokenResponse = JSON.parse(localStorage.getItem('tokenResponse'));
        return Promise.resolve(tokenResponse);
      }

      const tokenResponse = new Promise((resolve, reject) => {
        try {
          tokenClient.callback = (resp) => {
            if (resp.error !== undefined) {
              reject(resp.error);
            } else {
              localStorage.setItem('consent', 'true');
              localStorage.setItem('tokenResponse', JSON.stringify(resp));
              localStorage.setItem('tokenExpires', Date.now() + resp.expires_in * 1000);
              resolve(resp);
            }
          };
          if (localStorage.getItem('consent') !== 'true') {
            tokenClient.requestAccessToken({ prompt: 'consent' });
          } else {
            tokenClient.requestAccessToken({ prompt: '' });
          }
        } catch (error) {
          console.log(error);
        }
      });
      return tokenResponse;
    }

    // monkeypatching datacube.js to fetch the correct img and segmentation data
    const original_binary_get = binary_get;
    binary_get = (url, progressfn) => {
      if (url.endsWith('/channel')) {
        return new Promise((fulfill, reject) => {
          const arrayBuffer = PARAMETERS.data[0].buffer;
          fulfill(arrayBuffer);
        });
      }
      if (url.endsWith('/segmentation')) {
        return new Promise((fulfill, reject) => {
          const arrayBuffer = PARAMETERS.data[1].buffer;
          fulfill(arrayBuffer);
        });
      }
      return original_binary_get(url, progressfn);
    }

    function downloadImageAsArrayBuffer(imageUrl, mimetype = "image/png") {
      return fetch(`${imageUrl}?cacheBuster=${Date.now()}`, { cache: 'no-cache' })
        .then(response => {
          if (!response.ok) {
            throw new Error(`Error while downloading ${imageUrl} Network response was not ok`);
          }
          return response.arrayBuffer();
        })
        .then(arrayBuffer => {
          const blob = new Blob([arrayBuffer], { type: mimetype });
          return createImageBitmap(blob);
        })
        .then(imageBitmap => {
          const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
          const context = canvas.getContext('2d', { alpha: false });
          context.drawImage(imageBitmap, 0, 0);
          return context.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data.buffer;
        })
        .catch(error => {
          console.error('There was a problem with the fetch operation:', error);
        });
    }

    function toHTTPS(url) {
      url = url.replace(/^gs:\/\//, 'https://storage.googleapis.com/');
      return url;
    }

    function normalizeURL(url) {
      url = url.replace(/^precomputed:\/\//, '');
      url = url.replace(/\/+$/, '')  // remove trailing slashes
      return url;
    }

    function getMIME(extension) {
      if (extension === "jpeg") {
        return "image/jpeg";
      }
      else if (extension === "png") {
        return "image/png";
      }
      else {
        throw new Error("Unsupported extension");
      }
    }

    function parseGCSPath(gcsPath) {
      let pathWithoutScheme = gcsPath.replace(/^gs:\/\//, '');
      pathWithoutScheme = pathWithoutScheme.replace("^https://storage.googleapis.com\/", '');

      const firstSlashIndex = pathWithoutScheme.indexOf('/');
      const bucketName = pathWithoutScheme.substring(0, firstSlashIndex);
      const remainingPath = firstSlashIndex !== -1 ? pathWithoutScheme.substring(firstSlashIndex + 1) : "";

      return {
        bucketName: bucketName,
        objectName: remainingPath
      };
    }

    function validatePrecomputedInfo(info) {
      errors = []
      if (info.scales.length !== 1) {
        errors.push("Layer contains multiple resolutions. Only one is supported.")
      }
      if (info.data_type !== "uint8") {
        errors.push("Data type must be uint8.")
      }
      if (info.num_channels !== 1) {
        errors.push("Layer must have only one channel.")
      }
      if (info.type !== "image" && info.type !== "segmentation") {
        errors.push("Layer must be of type image or segmentation.")
      }
      if (info.type == "segmentation" && info.scales[0].encoding !== "png") {
        errors.push("Segmentation layer must be encoded as png.")
      }
      if (info.type == "image" && info.scales[0].encoding !== "jpeg" && info.scales[0].encoding !== "png") {
        errors.push("Image layer must be encoded as jpeg or png.")
      }
      if (
        (info.scales[0].size[0] !== info.scales[0].chunk_sizes[0][0]) ||
        (info.scales[0].size[1] !== info.scales[0].chunk_sizes[0][1]) ||
        (info.scales[0].size[2] !== info.scales[0].chunk_sizes[0][2])
      ) {
        errors.push("Currently entire volume must consist of a single chunk.")
      }
      if (info.scales[0].size[0] * info.scales[0].size[1] * info.scales[0].size[2] >= 2147483647) {
        errors.push("Volume size must be less than 2 GVx.")
      }
      if (info.scales[0].size[1] * info.scales[0].size[2] > 65535) {
        errors.push("Product of Y and Z dimension must be 65535 or less.")
      }

      if (errors.length > 0) {
        throw new Error(errors.join("\n"));
      }
      return true
    }

    $(document).ready(function () {
      elems = {
        cloudpath: $('#cloudpath'),
        bounds: $('#bounds'),
        dtype: $('#dtype'),
        resolution: $('#resolution'),
        shape: $('#shape'),
        axis: $('#axis'),
        coord: $('#coord'),
        realcoord: $('#realcoord'),
        clickcoord: $('#clickcoord'),
        clickrealcoord: $('#clickrealcoord'),
        loading: $('#loading'),
        pxvalue: $('#pxvalue'),
        clickpxvalue: $('#clickpxvalue'),
        channel: $('#channel'),
        selected_segments: $('#selected_segments'),
        addsegs: $('#addsegs'),
        show_hover: $('#show_hover'),
        show_unselected: $('#show_unselected'),
        magnification: $('#magnification'),
        showsidebar: $('#show-sidebar'),
        rtsidebar: $('#right-sidebar'),
        copysegs: $("#copy-segs"),
        brushsize: $("#brush-size"),
        paintmode: $("#paint_voxels"),
        paintlabel: $("#paintlabel"),
        memoryusage: $("#memory-usage"),
      };

      const urlParams = new URLSearchParams(window.location.search);

      const imgPath = normalizeURL(urlParams.get('img_path'));
      const segPath = normalizeURL(urlParams.get('seg_path'));
      const imgInfoPath = imgPath + '/info';
      const segInfoPath = segPath + '/info';

      SIZE = { x: 0, y: 0, z: 0 };
      let data = {
        viewtype: 'hyper',
        cloudpath: [imgPath, segPath],
        data_types: ["uint8", "uint8"],
        data_bytes: [1, 1],
        data: [null, null],
        bounds: ['?', '?', '?', '?', '?', '?'],
        resolution: ['?', '?', '?']
      }

      let imgReadyResolve, imgReadyReject;
      let imgReady = new Promise((resolve, reject) => {
        imgReadyResolve = resolve;
        imgReadyReject = reject;
      });

      let segReadyResolve, segReadyReject;
      let segReady = new Promise((resolve, reject) => {
        segReadyResolve = resolve;
        segReadyReject = reject;
      });

      fetch(toHTTPS(imgInfoPath) + `?cacheBuster=${Date.now()}`, { cache: 'no-cache' })
        .then(response => response.json())
        .then(imgInfo => {
          if (validatePrecomputedInfo(imgInfo)) {
            const voxelOffset = imgInfo.scales[0].voxel_offset;
            const size = imgInfo.scales[0].size;
            data.bounds = [voxelOffset[0], voxelOffset[1], voxelOffset[2], voxelOffset[0] + size[0], voxelOffset[1] + size[1], voxelOffset[2] + size[2]];
            data.resolution = imgInfo.scales[0].resolution;

            const boundsStr = `${data.bounds[0]}-${data.bounds[3]}_${data.bounds[1]}-${data.bounds[4]}_${data.bounds[2]}-${data.bounds[5]}`;
            const imgDataUrl = [toHTTPS(imgPath), imgInfo.scales[0].key, boundsStr].join('/');

            downloadImageAsArrayBuffer(imgDataUrl, mimetype = getMIME(imgInfo.scales[0].encoding))
              .then((arrayBuffer) => {
                imgDataRGBA = new Uint8Array(arrayBuffer);
                data.data[0] = new Uint8Array(imgDataRGBA.length / 4);
                for (let i = 0; i < data.data[0].length; i++) {
                  data.data[0][i] = imgDataRGBA[i * 4];
                }
                imgReadyResolve();
              });


            SIZE.x = size[0]
            SIZE.y = size[1]
            SIZE.z = size[2]
          }
        });

      fetch(toHTTPS(segInfoPath) + `?cacheBuster=${Date.now()}`, { cache: 'no-cache' })
        .then(response => response.json())
        .then(segInfo => {
          if (validatePrecomputedInfo(segInfo)) {
            const voxelOffset = segInfo.scales[0].voxel_offset;
            const size = segInfo.scales[0].size;
            const boundsStr = `${voxelOffset[0]}-${voxelOffset[0] + size[0]}_${voxelOffset[1]}-${voxelOffset[1] + size[1]}_${voxelOffset[2]}-${voxelOffset[2] + size[2]}`;
            const segDataUrl = [toHTTPS(segPath), segInfo.scales[0].key, boundsStr].join('/');

            downloadImageAsArrayBuffer(segDataUrl, mimetype = getMIME(segInfo.scales[0].encoding))
              .then((arrayBuffer) => {
                segDataRGBA = new Uint8Array(arrayBuffer);
                data.data[1] = new Uint8Array(segDataRGBA.length / 4);  // Adjust for 16bit
                for (let i = 0; i < data.data[1].length; i++) {
                  data.data[1][i] = segDataRGBA[i * 4];
                }
                segReadyResolve();
              });
          }
        });

      window.channel = elems.channel[0];
      window.channelctx = channel.getContext('2d');

      Promise.all([imgReady, segReady]).then(function () {
        PARAMETERS = data;

        if (data.viewtype === 'single') {
          setup_single_volume(data);
        }
        else {
          setup_hyper_volume(data);
        }

        $(channel).on('mouseout', function (e) {
          PXVALUE = [];
          vol.hover_id = null;
          render(true);
        });

        $(channel).on('click', function (e) {
          var x = e.offsetX / $(this).innerWidth(),
            y = e.offsetY / $(this).innerHeight();

          x = clamp(x, 0, 0.999999999);
          y = clamp(y, 0, 0.999999999);

          if (AXIS == 'z') {
            CLICK.x = (x * SIZE.x) | 0;
            CLICK.y = (y * SIZE.y) | 0;
            CLICK.z = SLICE.z;
          }
          else if (AXIS == 'y') {
            CLICK.x = (x * SIZE.x) | 0;
            CLICK.z = (y * SIZE.z) | 0;
            CLICK.y = SLICE.y;
          }
          else if (AXIS == 'x') {
            CLICK.y = (x * SIZE.y) | 0;
            CLICK.z = (y * SIZE.z) | 0;
            CLICK.x = SLICE.x;
          }

          CLICK.pxvalue = [vol.channel.get(CLICK.x, CLICK.y, CLICK.z)];

          if (vol.segmentation) {
            CLICK.pxvalue.push(
              vol.renumbering[vol.segmentation.get(CLICK.x, CLICK.y, CLICK.z)]
            );
          }
          else if (vol.has_segmentation) {
            CLICK.pxvalue[0] = vol.renumbering[CLICK.pxvalue[0]];
          }

          render();
        });

        if (data.viewtype === "hyper") {
          $(document).on('keydown', function (evt) {
            if (evt.keyCode === 16 && !evt.ctrlKey) {
              if (evt.originalEvent.code === "ShiftRight") {
                vol.hide_channel = true;
              }
              else {
                vol.hide_segmentation = true;
              }
              render(true);
            }
          });

          $(document).on('keyup', function (evt) {
            if (evt.keyCode === 16 && !evt.ctrlKey) {
              if (evt.originalEvent.code === "ShiftRight") {
                vol.hide_channel = false;
              }
              else {
                vol.hide_segmentation = false;
              }
              render(true);
            }
          });
        }

        loop();
      }).catch(function (error) {
        console.error("Img or Segmentation download failed:", error);
      });

      elems.paintlabel.on("keyup keypress keydown", function (evt) {
        evt.stopPropagation();
      });

      elems.showsidebar.on("click", function () {
        toggleMenu();
      });

      elems.copysegs.on("click", function () {
        navigator.clipboard.writeText(elems.selected_segments.text());
      });

      elems.addsegs.on("keypress keydown", function (evt) {
        evt.stopPropagation();
      });

      elems.addsegs.on("keyup", function (evt) {
        evt.stopPropagation();
        if (evt.keyCode !== 13) {
          return;
        }

        var val = elems.addsegs.val().replace(/\s/g, "");
        if (val === "") {
          return;
        }

        val
          .split(",")
          .map((x) => BigInt(x))
          .forEach((segid) => vol.selectSegment(segid));

        elems.addsegs.val("");
        elems.addsegs.blur();
        vol.hover_id = null;
        Undo.push('select');
        render(true);
      });

      elems.rtsidebar.on('wheel', function (e) {
        e.stopPropagation();
      });
    });

    $(document).on('wheel', function (e) {
      var delta = clamp(e.originalEvent.deltaY, -1, 1);
      delta = -Math.round(delta);
      move_slice(delta);
    });

    var AXES = ['z', 'y', 'x'];
    var ZOOMED = false;
    var ZOOM_FACTOR = 10;

    function zoomTo() {
      let x = 0;
      let y = 0;
      let sx = 0;
      let sy = 0;
      if (AXIS == 'z') {
        x = SLICE.x;
        y = SLICE.y;
        sx = SIZE.x;
        sy = SIZE.y;
      }
      else if (AXIS == 'y') {
        x = SLICE.x;
        y = SLICE.z;
        sx = SIZE.x;
        sy = SIZE.z;
      }
      else if (AXIS == 'x') {
        x = SLICE.y;
        y = SLICE.z;
        sx = SIZE.y;
        sy = SIZE.z;
      }

      if (ZOOMED) {
        elems.channel.css('transform', '');
      }
      else if (MAGNIFICATION > ZOOM_FACTOR) {
        return;
      }
      else {
        let zfactor = ZOOM_FACTOR / MAGNIFICATION;
        let dx = x / sx - 0.5;
        let dy = y / sy - 0.5;

        dx *= elems.channel.width() * zfactor;
        dy *= elems.channel.height() * zfactor;

        elems.channel.css('transform', `matrix(${zfactor},0,0,${zfactor},${-dx},${-dy})`);
      }
      ZOOMED = !ZOOMED;
    }

    $(document).on('keyup', function (evt) {
      if (evt.keyCode === 'A'.charCodeAt(0)) {
        rotate_axis(2);
      }
      else if (evt.keyCode === 'D'.charCodeAt(0)) {
        rotate_axis(1);
      }
      else if (evt.keyCode === ' '.charCodeAt(0)) {
        zoomTo();
      }
      else if (evt.keyCode === 'Q'.charCodeAt(0)) {
        BRUSH = Math.max(BRUSH - 1, 0);
        render(true);
      }
      else if (evt.keyCode === 'E'.charCodeAt(0)) {
        BRUSH = Math.min(BRUSH + 1, 3);
        render(true);
      }
      else if (evt.keyCode === "I".charCodeAt(0)) {
        invertSelection();
      }
      else if (
        evt.keyCode === 'Z'.charCodeAt(0) && evt.ctrlKey
      ) {
        if (evt.shiftKey) {
          UNDO.redo();
        }
        else {
          UNDO.undo();
        }
      }
    });

    $(document).on('keypress', function (evt) {
      if (evt.keyCode === 'W'.charCodeAt(0)
        || evt.keyCode === 'w'.charCodeAt(0)
        || evt.keyCode === '.'.charCodeAt(0)
        || evt.keyCode === 190) {

        move_slice(1);
      }
      else if (evt.keyCode === 'S'.charCodeAt(0)
        || evt.keyCode === 's'.charCodeAt(0)
        || evt.keyCode === ','.charCodeAt(0)
        || evt.keyCode === 188) {

        move_slice(-1);
      }
      else if (evt.keyCode === 'L'.charCodeAt(0)
        || evt.keyCode === 'l'.charCodeAt(0)
      ) {

        vol.shuffleColors();
        render(true);
      }
      else if (evt.keyCode === 'X'.charCodeAt(0)
        || evt.keyCode === 'x'.charCodeAt(0)) {

        if (vol.clearSelected) {
          UNDO.push();
          vol.clearSelected()
        }
        render(true);
      }
      else if (
        evt.keyCode === '='.charCodeAt(0) // '+' without shift
        || evt.keyCode === '+'.charCodeAt(0)
        || evt.keyCode === 107 // '+' sometimes
      ) {
        vol.alpha = clamp(vol.alpha + 0.1, 0, 1);
        render();
      }
      else if (evt.keyCode === '-'.charCodeAt(0)) {
        vol.alpha = clamp(vol.alpha - 0.1, 0, 1);
        render();
      }
      else if (evt.keyCode === "H".charCodeAt(0)
        || evt.keyCode === "h".charCodeAt(0)) {

        elems.show_hover.prop("checked",
          !elems.show_hover.prop("checked")
        );
      }
      else if (evt.keyCode === "M".charCodeAt(0)
        || evt.keyCode === "m".charCodeAt(0)) {

        toggleMenu();
      }
      else if (evt.keyCode === "U".charCodeAt(0)
        || evt.keyCode === "u".charCodeAt(0)) {

        elems.show_unselected.prop("checked",
          !elems.show_unselected.prop("checked")
        );
        render(true);
      }
      else if (evt.keyCode === "P".charCodeAt(0)
        || evt.keyCode === "p".charCodeAt(0)) {

        elems.paintmode.prop("checked",
          !elems.paintmode.prop("checked")
        );
      }
      else if (evt.keyCode === "1".charCodeAt(0)) {
        MAGNIFICATION /= 2;
        MAGNIFICATION = Math.max(MAGNIFICATION, 0.25);
        elems.channel.css("width", (channel.width * MAGNIFICATION) + "px");
        elems.channel.css("height", (channel.height * MAGNIFICATION) + "px");
        elems.channel.css('transform', '');
        render();
      }
      else if (evt.keyCode === "2".charCodeAt(0)) {
        MAGNIFICATION *= 2;
        MAGNIFICATION = Math.min(MAGNIFICATION, 256);
        elems.channel.css("width", (channel.width * MAGNIFICATION) + "px");
        elems.channel.css("height", (channel.height * MAGNIFICATION) + "px");
        elems.channel.css('transform', '');
        render();
      }

      elems.show_unselected.on('click', function () {
        render(true);
      });

      $("#brush-size div.exact").on("click", function () {
        BRUSH = 0;
        render(true);
      });
      $("#brush-size div.small").on("click", function () {
        BRUSH = 1;
        render(true);
      });
      $("#brush-size div.medium").on("click", function () {
        BRUSH = 2;
        render(true);
      });
      $("#brush-size div.large").on("click", function () {
        BRUSH = 3;
        render(true);
      });

    });

    function rotate_axis(delta) {
      if (PAINTING_MODE) {
        UNDO.push();
      }

      let index = (AXES.indexOf(AXIS) + delta) % AXES.length;
      AXIS = AXES[index];

      let face_dims = vol.channel.faceDimensions(AXIS);

      elems.channel.css("width", (face_dims[0] * MAGNIFICATION) + "px");
      elems.channel.css("height", (face_dims[1] * MAGNIFICATION) + "px");

      render();
    }

    function move_slice(delta) {
      if (PAINTING_MODE) {
        UNDO.push();
      }

      SLICE[AXIS] += delta;
      SLICE[AXIS] = clamp(SLICE[AXIS], 0, SIZE[AXIS] - 1);
      render();
    }

    function render_static() {
      if (PARAMETERS.viewtype === 'single') {
        $('#instructions .hyperview').hide();

        if (PARAMETERS.layer_type === 'image') {
          $('#instructions .segmentation').hide();
        }
        else {
          $(channel).addClass("paintable");
        }

        PARAMETERS.cloudpath[0].split('/')
      }
      else {
        $(channel).addClass("paintable");
      }

      let hyper = (PARAMETERS.viewtype === 'hyper') ? 'Hyper ' : '';
      let firstlayer = PARAMETERS.cloudpath[0];

      if (firstlayer === 'IN MEMORY') {
        document.title = `MEMORY - ${hyper}μViewer`;
      }
      else if (firstlayer) {
        document.title = `${PARAMETERS.cloudpath.join(" ; ")} - ${hyper}μViewer`;
      }

      elems.channel.css('width', SIZE.x + 'px').css('height', SIZE.y + 'px');

      let b = PARAMETERS.bounds;
      elems.cloudpath.text(PARAMETERS.cloudpath.join("; "));
      elems.bounds.text(
        `<${b[0]}, ${b[1]}, ${b[2]}>, <${b[3]}, ${b[4]}, ${b[5]}>`
      );
      elems.dtype.text(PARAMETERS.data_types.join("; "));
      elems.resolution.text(PARAMETERS.resolution.join('x'));
      elems.shape.text(`<${SIZE.x}, ${SIZE.y}, ${SIZE.z}>`);

      let bytes = PARAMETERS["data_bytes"];

      if (Array.isArray(bytes)) {
        bytes = bytes.reduce((partialSum, a) => partialSum + a, 0);
      }
      bytes *= SIZE.x * SIZE.y * SIZE.z;
      let megabytes = bytes / 1e6;
      if (megabytes < 1) {
        elems.memoryusage.text(`${(megabytes * 1000) | 0} kB`);
      }
      else {
        elems.memoryusage.text(`${megabytes | 0} MB`);
      }
    }

    function update_pxvalue() {
      PXVALUE = [];

      vol.hover_id = null;
      if (vol.segmentation) {
        PXVALUE.push(vol.channel.get(SLICE.x, SLICE.y, SLICE.z));
        vol.hover_id = vol.segmentation.get(SLICE.x, SLICE.y, SLICE.z);
        PXVALUE.push(vol.renumbering[vol.hover_id]);
      }
      else if (vol.has_segmentation) {
        vol.hover_id = vol.channel.get(SLICE.x, SLICE.y, SLICE.z);
        PXVALUE.push(vol.renumbering[vol.hover_id]);
      }
      else {
        PXVALUE.push(vol.channel.get(SLICE.x, SLICE.y, SLICE.z));
      }

      if (!MOUSE_OVER_IMAGE || !elems.show_hover.prop('checked')) {
        vol.hover_id = null;
      }
    }

    function render(invalidate_cache = false) {
      update_pxvalue();
      if (invalidate_cache) {
        vol.cache.valid = false;
      }
      _needsrender = true;
    }

    function hardRender() {
      if (AXIS == 'z') {
        channel.width = SIZE.x;
        channel.height = SIZE.y;
      }
      else if (AXIS == 'y') {
        channel.width = SIZE.x;
        channel.height = SIZE.z;
      }
      else if (AXIS == 'x') {
        channel.width = SIZE.y;
        channel.height = SIZE.z;
      }

      vol.show_unselected = elems.show_unselected.prop('checked');
      vol.render(window.channelctx, AXIS, SLICE[AXIS]);

      // compute real coordinate as well
      let b = PARAMETERS.bounds;
      let real = [SLICE.x + b[0], SLICE.y + b[1], SLICE.z + b[2]];
      const is_offset = (b[0] != 0) || (b[1] != 0) || (b[2] != 0);

      elems.axis.text(AXIS);
      elems.coord.text(`<${SLICE.x}, ${SLICE.y}, ${SLICE.z}>`);

      if (is_offset) {
        elems.realcoord.text(`(${real[0]}, ${real[1]}, ${real[2]})`);
      }

      real = [CLICK.x + b[0], CLICK.y + b[1], CLICK.z + b[2]];

      elems.clickcoord.text(`<${CLICK.x}, ${CLICK.y}, ${CLICK.z}>`);

      if (is_offset) {
        elems.clickrealcoord.text(`(${real[0]}, ${real[1]}, ${real[2]})`);
      }

      if (vol.loaded()) {
        elems.loading.hide();
      }
      else {
        elems.loading.text((vol.progress() * 100).toFixed(0) + '%');
      }

      elems.magnification.text(`${MAGNIFICATION}x`);

      if (PXVALUE.length) {
        elems.pxvalue.show().text("value: " + PXVALUE.map(display_value).join("; "));
      }
      else {
        elems.pxvalue.hide();
      }

      if (CLICK.pxvalue.length) {
        elems.clickpxvalue.text("value: " + CLICK.pxvalue.map(display_value).join("; "));
      }
      else {
        elems.clickpxvalue.text("");
      }

      if (vol.segments) {
        elems.selected_segments.text(
          vol.selected().join(', ')
        );
      }

      if (BRUSH === 0) {
        $(channel).removeClass("small medium large").addClass("exact");
        elems.brushsize.removeClass("small medium large").addClass("exact");
      }
      else if (BRUSH === 1) {
        $(channel).removeClass("exact medium large").addClass("small");
        elems.brushsize.removeClass("exact medium large").addClass("small");
      }
      else if (BRUSH === 2) {
        $(channel).removeClass("exact small large").addClass("medium");
        elems.brushsize.removeClass("exact small large").addClass("medium");
      }
      else {
        $(channel).removeClass("exact medium small").addClass("large");
        elems.brushsize.removeClass("exact medium small").addClass("large");
      }

      _needsrender = false;
    }

    function display_value(val) {
      if (PARAMETERS.is_floating) {
        return val.toFixed(4);
      }
      else if ( // color image
        PARAMETERS.layer_type == "image" && PARAMETERS.data_bytes == 4
      ) {
        return `${val} rgb: <${val & 0xff}, ${(val >> 8) & 0xff}, ${(val >> 16) & 0xff}>`;
      }
      return val;
    }

    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }

    function loop() {
      if (_needsrender) {
        hardRender();
      }

      requestAnimationFrame(loop);
    }

    function saveNumpy() {
      let d = new Date();
      let filename = `image-${d.getFullYear()}-${d.getMonth()}-${d.getDay()}.npy`;
      vol.getSegmentation().saveNumpy(filename);
    }

    function saveCrackle() {
      let d = new Date();
      let filename = `image-${d.getFullYear()}-${d.getMonth()}-${d.getDay()}.ckl`;
      vol.getSegmentation().saveCrackle(filename);
    }

    function invertSelection() {
      vol.invertSelection();
      UNDO.push('select');
      render(true);
    }
  </script>
</head>

<body>
  <div id="infobar">
    <span id="axis"></span> <span id="magnification"></span> <span id="coord"></span> <span id="realcoord"></span> <span
      id="pxvalue"></span>
    <br>
    Last Click: <span id="clickcoord"></span> <span id="clickrealcoord"></span> <span id="clickpxvalue"></span> <span
      id="loading"></span>
  </div>

  <div id="show-sidebar">
    <hr />
    <hr />
    <hr />
  </div>
  <div id="right-sidebar">
    <div id="instructions">
      <div id="basic-info">
        <span id="cloudpath"></span>
        <p>DIMENSIONS</p>
        shape: <span id="shape"></span>
        <br />
        bounds: (<span id="bounds"></span>)
        <br />
        dtype: <span id="dtype"></span>
        <br />
        resolution: <span id="resolution"></span> nm<sup>3</sup>
        <br />
        memory: <span id="memory-usage"></span>
      </div>

      <p class="segmentation">SELECTION VISIBILITY</p>
      <input class="segmentation" type="checkbox" id="show_hover" name="show_hover" checked="checked" /> <label
        class="segmentation" for="show_hover">Highlight (H)over?</label>
      <input class="segmentation" type="checkbox" id="show_unselected" name="show_unselected" /> <label
        class="segmentation" for="show_unselected">Show (U)nselected?</label> <br />
      <input class="segmentation" type="checkbox" id="paint_voxels" name="paint_voxels" /> <label class="segmentation"
        for="paint_voxels">Direct (P)aint?</label>

      <p class="segmentation">BRUSH SIZE</p>
      <div id="brush-tools" class="segmentation">
        <div id="brush-size">
          <div class="exact"></div>
          <div class="small"></div>
          <div class="medium"></div>
          <div class="large"></div>
        </div>
        <button id="invert-selection" onclick="invertSelection()">invert selection</button>
      </div>

      <p class="segmentation">PAINT LABEL</p>
      <div class="segmentation">
        <input id="paintlabel" type="number" value="1" />
      </div>

      <p class="segmentation">SELECTED SEGMENTS <button id="copy-segs">copy</button></p>
      <div class="segmentation" id="selected_segments"></div>
      <textarea id="addsegs" class="segmentation" type="text"
        placeholder="Input comma separated segids and press enter."></textarea>

      <p class="segmentation">SAVE SEGMENTATION</p>

      <div class="segmentation">
        <button id="gcsUpload" onclick="uploadSegmentationToGCS()"
          title="Upload a .png file to your Google Cloud Storage bucket." disabled>GCS</button>
        <progress id="gcsUploadProgress" value="0" max="100" hidden></progress>
      </div>

      <p>CONTROLS</p>
      <ul>
        <li>W/S ,/. or scroll - advance selected images</li>
        <li>A/D - switch slicing plane</li>
        <li>Space - zoom in to point</li>
        <li class='segmentation'>L - recolor segmentation labels</li>
        <li>Left Click - <span class="segmentation">paint, </span>freeze info about current pixel</li>
        <li class="segmentation">Right Click - erase</li>
        <li class="segmentation">X - clear selected segments</li>
        <li class="hyperview">left shift - hide segmentation</li>
        <li class="hyperview">right shift - hide channel</li>
        <li class="hyperview">+/- increase, decrease opacity</li>
        <li class='segmentation'>H - toggle hover highlight</li>
        <li class='segmentation'>U - toggle show unselected</li>
        <li class='segmentation'>P - toggle direct voxel painting</li>
        <li class='segmentation'>I - invert selection</li>
        <li>1/2 - zoom out/in</li>
        <li>M - show/hide menu</li>
        <li class="segmentation">Q/E - decrease/increase brush size</li>
        <li class="segmentation">ctrl+Z - undo</li>
        <li class="segmentation">ctrl+shift+Z - redo</li>
      </ul>
    </div>
  </div>

  <canvas oncontextmenu="return false;" id="channel" class="exact" width="256" height="256"></canvas>

</body>

</html>